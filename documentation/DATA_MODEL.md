# Модель данных MGCOM Finance AI

## 1. Источники данных

В рамках проекта планируется использовать следующие Excel‑файлы (размещены в директории `data-files/`):

- `клиенты-ai.xlsx` — справочник клиентов:
  - наименование клиента;
  - ИНН/КПП (если есть);
  - отрасль/тип;
  - ответственный менеджер;
  - статус (активный, потенциальный, потерянный и т.п.).
- `Контакты-ai.xlsx` — контактные лица по клиентам:
  - клиент (ссылка/название, совпадает с полем в `клиенты-ai.xlsx`);
  - ФИО контактного лица;
  - должность;
  - телефон/почта;
  - комментарии.
- `NewBiz - Все тендеры.xlsx` — лог тендеров и сделок:
  - клиент;
  - сумма;
  - дата начала/окончания;
  - статус (выигран/проигран/в процессе);
  - ответственное подразделение/менеджер;
  - дополнительные атрибуты (тип тендера, канал привлечения и т.п.).

## 2. Логические таблицы

На уровне приложения и ИИ мы оперируем **логическими таблицами**, которые абстрагируются от физических Excel‑файлов:

- **`clients`** — агрегированная информация о клиентах:
  - источник: `клиенты-ai.xlsx`;
  - ключевое поле: `client_name` (или эквивалент);
  - дополнительные поля: ответственное лицо, сегмент, статус и др.
- **`contacts`** — контакты по клиентам:
  - источник: `Контакты-ai.xlsx`;
  - ключевое поле: `contact_id` (внутренний идентификатор);
  - внешнее ключевое поле: `client_name` (ссылка на `clients`).
- **`tenders`** — тендеры и сделки:
  - источник: `NewBiz - Все тендеры.xlsx`;
  - ключевое поле: `tender_id`;
  - внешний ключ: `client_name` (ссылка на `clients`);
  - числовые поля: сумма, маржа, длительность и т.п.;
  - датовые поля: дата начала, дата завершения.

Эти имена таблиц используются в `systemPrompt` для YandexGPT и в структуре `TableRequest`.

## 3. Связи между таблицами

Базовая схема связей (MVP):

- `clients (1)` — `contacts (N)`:
  - связь по полю `client_name`;
  - один клиент → много контактов.
- `clients (1)` — `tenders (N)`:
  - связь по полю `client_name`;
  - один клиент → много тендеров.

В будущем возможно:

- добавление таблицы `managers` с отдельным справочником менеджеров;
- выделение отдельных справочников отраслей, типов тендеров и т.д.

## 4. Текущая реализация (демо‑данные)

На момент создания этой документации фактическая реализация слоя данных следующая:

- В `lib/demoTable.ts` формируется демо‑таблица (колонки и строки) для выбранной логической таблицы;
- Маршрут `/api/data`:
  - принимает параметр `table` (`clients` по умолчанию);
  - вызывает `getDemoTable(table)`;
  - возвращает результат в формате:
    - `columns: { key, label, type }[]`;
    - `rows: Record<string, string | number | Date | null>[]`.
- Таблица на фронтенде (`DataTable`) не знает про Excel напрямую — она работает с абстрактными колонками и строками.

Таким образом, для подключения реальных данных нужно:

1. Заменить/расширить реализацию `getDemoTable` на чтение из Excel/БД.
2. Обеспечить приведение типов (строка/число/дата) к тем, которые ожидает `DataTable`.
3. Сохранить согласованность ключей колонок с теми, что используются в промптах и `TableRequest`.

## 5. Формат `TableRequest` (запрос к данным)

Структура `TableRequest`, с которой работает фронтенд (см. `ChatPanel.tsx` и `DataTable.tsx`):

```ts
export type TableRequest = {
  table?: "clients" | "contacts" | "tenders";
  description?: string;
  filters?: {
    field: string;
    operator: string;
    value: any;
  }[];
  columns?: string[];
  sort?: {
    field: string;
    direction: "asc" | "desc";
  } | null;
  limit?: number;
};
```

Эта структура:

- Генерируется YandexGPT (на основе `systemPrompt` в `/api/chat`).
- Используется:
  - в `Dashboard` для выбора нужной таблицы (`table`) и загрузки данных через `/api/data`;
  - в `DataTable` для:
    - выставления видимых колонок;
    - применения фильтров;
    - настройки сортировки.

## 6. Преобразование `TableRequest` в запрос к данным

В будущем серверный слой будет:

1. Принимать `TableRequest` (или его часть) на API‑уровне.
2. Транслировать его в SQL‑запросы/фильтры к таблицам Supabase (PostgreSQL).
3. Возвращать данные в формате, совместимом с `DataTable`:
   - `columns` — массив описаний колонок;
   - `rows` — массив объектов, где ключи совпадают с `columns.key`.

Это позволяет отделить:

- **Язык пользователя** (русский естественный язык);
- **Язык ИИ‑описания** (`TableRequest` как JSON);
- **Фактическую реализацию** (SQL, парсер Excel, кэш и т.п.).

